---
layout:     post                    # 使用的布局（不需要改）
title:      事务和隔离级别         # 标题 
subtitle:   sql  #副标题
date:       2020-2-11          # 时间
author:     MistRay                      # 作者
header-img: img/post-bg-7.jpg #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - MySQL
    - SQL
---
### 前言
近两天在nCoV的影响下,大家都戴起了口罩,公司下达任务的强度也下降了,就想趁着这段时间重温下基础.在重温的过程中,一些原本自己认为已经掌握的很好的东西也渐渐模糊起来.  
写这一系列主要是因为看到了github上的一个库[mysql-deadlocks](https://github.com/aneasystone/mysql-deadlocks),主要记载了一些常见的MySQL死锁案例.里面有该库own写的关于死锁的博文,在阅读后才发现自己对于SQL乃至锁相关的知识是多么的薄弱.所以这里题主就想着做一下学习笔记,加深自己对该部分的理解,共同学习共同进步.  

### 事务的四要素ACID
* 原子性(Atomicity) : 要么全部完成,要么全部不完成
* 一致性(Consistency) : 一个事务单元要提交之后才会对其他事务可见
* 隔离性(Isolation) : 并发事务之间不会相互影响,设立了不同程度的隔离级别,通过适度破坏一致性,以提高性能
* 持久性(Durability) : 事务提交之后即持久化到磁盘上,不会丢失

### 事务存在的并发问题

现在有这样一张表,只有三个字段,主键id,姓名name和余额balance,其中name为二级索引

| id | name | balance |
| --- | --- | --- |
| 1 | A | 1000 |
| 2 | B | 1000 |
| 3 | C | 1000 |

#### 脏读

假设有两个事务,一个在进行转账操作,将A账户下的100块转到B账户,同时有另一个事务再拍对A和B的账户余额进行求和统计,如下图所示:

![脏读](/img/post_img/post_2020_02_11_01脏读.jpg)

事务1执行成功后,A余额900,B余额1100,总和为2000;但是事务2求和算出的结果是A+B=1900.这就是上面说的,没有提交的事务被其他事务读取到了,这就叫做**脏读**.

#### 不可重复读

第二种场景叫**不可重复读**,事务2第一次获取A的账户余额为1000元,这个时候事务1对A的账户余额操作减去了100元,事务2再去查询A的账户余额发现变成了900元,
这样就出现了同一个事务对同一条记录读取两遍,两次读出的结果竟然不一样.

![不可重复读](/img/post_img/post_2020_02_11_02不可重复读.jpg)

不可重复读和脏读的区别在于,脏读是读取了另一个事务未提交的修改,而不可重复读是读取了另一个事务提交之后的修改,
本质上都是其他事务的修改影响了本事务的读取.那么不可重复读有什么问题呢? 假设上面的事务2存在两个子例程,第一个例程是读取所有账户的余额计算总和,
可以得到所有人的余额总和为3000,第二个例程是读取所有账户的余额计算平均值,3个人总和3000按理应该是平均每人1000才对,却计算出了2900/3=966,这就导致了数据不一致.

#### 幻读
关于幻读,大概是事务中存在的并发问题中最难理解的部分了.关于幻读,最简单的解释是:**同样的条件,第一次和第二次读出来的记录数不一样.(注意是记录数)**
幻读和不可重复读的区别在于,后者是两次读取同一条数据,得到不一样的结果;而前者是两次读取同一个范围内的记录,得到不一样的记录数
(这种说法其实只是便于理解,但并不准确,因为可能存在另一个事务先插入一条记录然后再删除一条记录的情况,这个时候两次查询得到的记录数是相同的,
但这也是幻读,所以严格点的说法是:**两次读取得到的结果集相同**).

`不可重复读是因为其他事务进行了UPDATE操作,幻读是因为其他事务进行了INSERT或者DELETE操作.`   

下面举一个幻读的例子:
![幻读](/img/post_img/post_2020_02_11_03幻读.jpg)

在事务2的两次查询中,第一次查出两条记录,第二次却查出3条记录,多出来的这条记录,就像幽灵(phantom)一样.





## Reference
[解决死锁之路](https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html)

## 转载
本文遵循 [CC 4.0 by-sa](https://creativecommons.org/licenses/by-sa/4.0/) 版权协议,转载请附上原文出处链接和本声明。