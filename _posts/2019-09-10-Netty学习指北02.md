---
layout:     post                    # 使用的布局（不需要改）
title:      Netty学习指北02-Netty网络抽象的代表         # 标题 
subtitle:   netty #副标题
date:       2019-09-09             # 时间
author:     MistRay                      # 作者
header-img: img/5b90dfe775237.jpg #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - netty
---
## Netty学习指北

## Netty网络抽象的代表
Channel,EventLoop,ChannelFuture结合在一起可以被认为是网络抽象的代表.

####  Channel->Socket
基本的I/O操作(bind,connect,read,write)依赖于底层网络传输所提供的原语.
在基于Java的网络编程中,其基本的构造是class Socket.Netty的Channel接口锁提供的API,
大大的降低了直接使用Socket的复杂性.此外,Channel也是拥有许多预定义的,专门化实现的广泛类层次结构的根,
下面是一个简短的部分清单:
* EmbeddedChannel
* LocalServerChannel
* NioDatagramChannel
* NioSctpChannel
* NioSocketChannel

####  EventLoop->控制流,多线程处理,并发
EventLoop定义了Netty的核心抽象,用于处理连接的生命周期中所发生的事件.
![post_2019_09_11_01.png](/img/post_img/post_2019_09_11_01.png)

* 一个EventLoopGroup包含一个或者多个EventLoop.
* 一个EventLoop在它的生命周期内只和一个Thread绑定.
* 所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理
* 一个Channel在它的生命周期内只注册于一个EventLoop
* 一个EventLoop可能会被分配给一个或多个Channel

在这种设计中,一个给定Channel的I/O操作都是由相同的Thread执行的,实际上消除了对于同步的需要.

####  ChannelFuture->异步通知
Netty中所有的I/O操作都是异步的.因此一个操作可能不会立即返回,所以我们需要一种用于在之后某个时间点确定其结果的方法.
为此Netty提供了ChannelFuture接口,其addListener()方法注册了一个ChannelFutureListener,
以便在某个操作完成时(无论是否成功)得到通知.

可以将ChannelFuture看作是将来要执行的操作的结果的占位符.
它究竟什么时候被执行则可能取决于若干因素,因此不可能准确的预测,但是可以肯定的是它将会被执行.此外,
__所有属于同一个Channel的操作都被保证其将以它们被调用的顺序被执行__


## Reference
* [Netty实战](https://book.douban.com/subject/27038538/)
* [netty.io](https://netty.io/)
* [Netty 4.x User Guide](https://zhuanlan.zhihu.com/p/24955867)
* [Netty用户指南](https://github.com/waylau/netty-4-user-guide)
## 转载
本文遵循 [CC 4.0 by-sa](https://creativecommons.org/licenses/by-sa/4.0/) 版权协议，转载请附上原文出处链接和本声明。